#!/usr/bin/env bash
# Generate stub files for CI when Convex backend is not available

set -e

echo "Generating stub files for CI..."

# Create directories
mkdir -p convex/_generated
mkdir -p src

# Generate convex/_generated/server.ts stub
cat > convex/_generated/server.ts << 'EOF'
// Stub file for CI - generated by scripts/generate-stubs.sh

export interface QueryCtx {
  db: {
    query: (table: string) => {
      order: (order: string) => {
        take: (n: number) => Promise<any[]>;
      };
      withIndex: (name: string, predicate?: (q: any) => any) => {
        order: (order: string) => {
          take: (n: number) => Promise<any[]>;
        };
        take: (n: number) => Promise<any[]>;
      };
    };
    get: (id: any) => Promise<any>;
  };
}

export interface MutationCtx extends QueryCtx {
  db: {
    query: (table: string) => any;
    insert: (table: string, doc: any) => Promise<any>;
    patch: (id: any, fields: any) => Promise<void>;
    delete: (id: any) => Promise<void>;
    get: (id: any) => Promise<any>;
  };
}

export const query = <Args = any, Output = any>(config: {
  args?: Args;
  handler: (ctx: QueryCtx, args?: Args) => Promise<Output>;
}) => config;

export const mutation = <Args = any, Output = any>(config: {
  args?: Args;
  handler: (ctx: MutationCtx, args?: Args) => Promise<Output>;
}) => config;

export const action = (fn: any) => fn;
export const internalQuery = (fn: any) => fn;
export const internalMutation = (fn: any) => fn;
export const internalAction = (fn: any) => fn;
EOF

# Generate convex/_generated/api.ts stub
cat > convex/_generated/api.ts << 'EOF'
// Stub file for CI - generated by scripts/generate-stubs.sh
export const api = {
  tasks: {
    list: {} as any,
    getByStatus: {} as any,
    getWorkload: {} as any,
    listFiltered: {} as any,
    getById: {} as any,
    create: {} as any,
    update: {} as any,
  },
};
EOF

# Generate convex/_generated/dataModel.ts stub
cat > convex/_generated/dataModel.ts << 'EOF'
// Stub file for CI - generated by scripts/generate-stubs.sh

export type TableNames = string

export type Id<TableName extends TableNames = TableNames> = string & {
  __tableName: TableName
}

export type Doc<TableName extends TableNames = TableNames> = {
  _id: Id<TableName>
  _creationTime: number
} & Record<string, unknown>

// Keep the generic surface available for tests/types that import DataModel.
export type DataModel = Record<string, unknown>
EOF

# Generate src/routeTree.gen.ts stub
cat > src/routeTree.gen.ts << 'EOF'
// Stub file for CI - generated by scripts/generate-stubs.sh
// This is a minimal stub to satisfy TypeScript during CI when TanStack Router
// codegen hasn't run. The actual routeTree will be generated by the router plugin.

export const routeTree: any = {
  __root__: {} as any,
}
EOF

# Generate convex/_generated/dataModel.ts stub
cat > convex/_generated/dataModel.ts << 'EOF'
// Stub file for CI - generated by scripts/generate-stubs.sh

// Generic document type — returns `any` so tests can cast freely
export type Doc<_TableName extends string> = any
// Generic ID type — a branded string
export type Id<_TableName extends string> = string & { __tableName?: _TableName }
EOF

echo "✅ Stub files generated successfully"
